# Azure Pipeline that run basic continuous integration on a Terraform project

# This makes sure the pipeline is triggered every time code is pushed in the validation-testing example source, on all branches.
trigger:
  branches:
    include:
    - '*'
  paths:
    include:
    - 'samples/integration-testing/src/*'

variables:
  # There must be an Azure Service Connection with that name defined in your Azure DevOps settings. See https://docs.microsoft.com/en-us/azure/devops/pipelines/library/connect-to-azure?view=azure-devops
  serviceConnection: 'terraform-basic-testing-azure-connection'
  azureLocation: 'eastus'
  # Terraform settings
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)'
  terraformVersion: '0.12.25'

stages:
  - stage: TerraformContinuousIntegration
    displayName: Terraform Module - CI
    jobs:
    - job: TerraformContinuousIntegrationJob
      displayName: TerraformContinuousIntegration - CI Job
      pool:
        vmImage: ubuntu-20.04
      steps:
      ## Step 1: run the Checkov Static Code Analysis
      #- bash: $(terraformWorkingDirectory)/checkov.sh $(terraformWorkingDirectory)
      #  displayName: Checkov Static Code Analysis
      # Step 2: install Terraform on the Azure Pipelines agent
      - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-installer.TerraformInstaller@0
        displayName: 'Install Terraform'
       # inputs:
       #   terraformVersion: $(terraformVersion)
      # Step 3: run Terraform init to initialize the workspace
      - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
        displayName: 'Run terraform init'
        inputs:
          command: init
          backendType: azurerm
          backendServiceArm: 'terraform-basic-testing-azure-connection'
          backendAzureRmSubscriptionId: '37ed9c9a-0d39-4823-a06c-e8121b935f89'
          ensureBackend: true
          backendAzureRmResourceGroupName: 'Testresourcegroup1'
          backendAzureRmResourceGroupLocation: 'eastus'
          backendAzureRmStorageAccountName: 'gevernovateststor01'
          # azure storage account sku, used when creating the storage account
          backendAzureRmStorageAccountSku: 'Standard_LRS'
          # azure blob container to store the state file
          backendAzureRmContainerName: 'tfstate'
          # azure blob file name
          backendAzureRmKey: infrax.tfstate
          workingDirectory: $(terraformWorkingDirectory)
      # Step 4: run Terraform validate to validate HCL syntax
      - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
        displayName: 'Run terraform validate'
        inputs:
          command: validate
          workingDirectory: $(terraformWorkingDirectory)
      # Step 5: run Terraform plan to validate HCL syntax
      - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
        displayName: 'Run terraform plan'
        inputs:
          command: plan
          workingDirectory: $(terraformWorkingDirectory)
          environmentServiceName: $(serviceConnection)
          #commandOptions: -var location=$(azureLocation)
      # Step 5: run Terraform apply
      - task: charleszipp.azure-pipelines-tasks-terraform.azure-pipelines-tasks-terraform-cli.TerraformCLI@0
        displayName: 'Run terraform apply'
        inputs:
          command: apply
          workingDirectory: $(terraformWorkingDirectory)
          environmentServiceName: $(serviceConnection)
          #commandOptions: -var location=$(azureLocation)
      # Azure CLI v2
      - task: AzureCLI@2
        displayName: 'Create Guardrails Policy'
        inputs:
          azureSubscription: '567-gevernovabuildtestsub'
          scriptType: 'bash'
      	  workingDirectory: $(terraformWorkingDirectory)
          scriptLocation: 'scriptPath'
          scriptPath: '$(Pipeline.Workspace)/s/azpolicy.sh'